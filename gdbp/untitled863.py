# -*- coding: utf-8 -*-
"""Untitled863.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zj5hWtSGBvR4wwwo6D-2z2ItR2posvdR
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
if not hasattr(np, 'PINF'):
    np.PINF = np.inf
if not hasattr(np, 'NINF'):
    np.NINF = -np.inf

try:
    import jax
    from jax import jit
except ModuleNotFoundError:
#     %pip install --upgrade "jax[cpu]"
    import jax
    from jax import jit

# install commplax if not found
try:
    import commplax
except ModuleNotFoundError:
#     %pip install https://github.com/ChenHongBo0420/Comm/archive/master.zip
    import commplax

# install data api if not found
try:
    import labptptm2
except ModuleNotFoundError:
#     %pip install https://github.com/remifan/LabPtPTm2/archive/master.zip
#     %pip uninstall numcodecs zarr -y
#     %pip install "zarr==2.10.3" "numcodecs==0.10.2"
    import labptptm2

# install GDBP if not found
try:
    import gdbp
except ModuleNotFoundError:
#     %pip install https://github.com/ChenHongBo0420/Q/archive/main.zip
    import gdbp

import numpy as np
from tqdm.auto import tqdm
from functools import partial
import matplotlib.pyplot as plt

from commplax import util, comm
import jax
from commplax import equalizer as eq, xcomm, plot as cplt
from gdbp import gdbp_base as gb, data as gdat, plot as gplt

##############################################################################
# 1) 与原来相同的初始化 / 数据加载
##############################################################################
ds_train, ds_test = gdat.load(1, 0, 4, 2)[0], gdat.load(2, 0, 4, 2)[0]

def init_models(data: gdat.Input, **kwargs):
    mode  = kwargs.get('mode', 'train')
    steps = kwargs.get('steps', 3)
    dtaps = kwargs.get('dtaps', 271)
    ntaps = kwargs.get('ntaps', 71)
    rtaps = kwargs.get('rtaps', 61)
    xi    = kwargs.get('xi', 1.1)  # optimal xi for FDBP

    fdbp_init = partial(gb.fdbp_init, data.a, steps=steps)
    model_init = partial(gb.model_init, data)

    comm_conf = {'mode': mode, 'steps': steps, 'dtaps': dtaps, 'rtaps': rtaps}
    cdc  = model_init({**comm_conf, 'ntaps': 1,     'init_fn': fdbp_init(xi=0.0)},  [('fdbp_0',)], name='CDC')
    gdbp = model_init({**comm_conf, 'ntaps': ntaps, 'init_fn': fdbp_init(xi=xi)},   [],           name='GDBP')
    return cdc, gdbp

models_train = init_models(ds_train)
models_test  = init_models(ds_test, mode='test')



##############################################################################
# 2) 训练 / 测试循环中，拿到等化信号 z_out 并做后处理
##############################################################################
results_Q = []
results_BER = []

for model_train, model_test in tqdm(zip(models_train, models_test),
                                    total=2, desc='sweep models'):
    # 使用第三个最近的参数，因为末尾样本可能被色散损坏
    params_queue = [None] * 3

    # 训练
    for _, p, _ in gb.train(model_train, ds_train, n_iter=3000):
        params_queue.append(p)
        params = params_queue.pop(0)

    # 测试 (改用我们新的 test_and_get_signal)
    metric, z = gb.test(model_test, params, ds_test)

    # 提取全局 Q-factor (QSq.total)、BER
    results_Q.append(metric.QSq.total)
    results_BER.append(metric.BER.total)

    # ----------------------------------------------------------------------
    # 后处理：获取网络输出信号并做进一步频偏估计/相位分析
    # ----------------------------------------------------------------------
    z_out = z.val  # shape: (num_symbols, num_pol) 之类

    # 例：使用 framekfcpr 做卡尔曼频偏+相位跟踪，获取 (fo, phi)
    z_cpr, (fo_frames, phi_frames) = eq.framekfcpr(z_out, w0=ds_train.w0)
    # 假设你已经执行过:
    z_cpr, (fo_frames, phi_frames) = eq.framekfcpr(z_out, w0=ds_train.w0)

    N = z_out.shape[0]
    nframes = fo_frames.shape[0]
    n = 100  # frame size for eq.framekfcpr, 可根据实际设置
    # 插值
    fo_interp = np.interp(np.arange(N), np.arange(nframes)*n, fo_frames[:, 0])
    # 转成 MHz (假设36 Gbaud)
    fo_mhz = fo_interp * (36e9 / (2*np.pi) / 1e6)

    # 开始画图
    plt.figure(figsize=(6, 4), dpi=300)

    ax1 = plt.gca()
    # 画相位 (逐符号), 只示例取第一偏振 phi_frames[:,0]
    ax1.plot(phi_frames[:, 0].real, alpha=0.5, label='Phase noise')
    ax1.set_ylabel('Phase (rad)')
    ax1.set_xlabel('Symbol index')
    ax1.set_ylim([2.5, 3.5])  # 只作为示例，可自行调整

    ax2 = ax1.twinx()
    ax2.plot(fo_mhz, color='red', label='Freq. offset')
    ax2.set_ylabel('Freq offset (MHz)')

    # 若想加 inset zoom（放大局部）
    axins = ax1.inset_axes([0.12, 0.14, 0.3, 0.3])
    axins.plot(phi_frames[:, 0].real)
    axins.set_xlim(200000, 200500)
    axins.set_ylim(2.92, 3.4)
    axins.set_xticks([200000, 200250, 200500])
    axins.set_xticklabels(['0', '250', '500'])
    ax1.indicate_inset_zoom(axins, edgecolor="blue")

    plt.title('Phase noise & Frequency offset vs Symbol index')
    plt.show()


# 输出全局 Q-factor 的结果
print("Q-factor results:", results_Q)
print("BER results:     ", results_BER)