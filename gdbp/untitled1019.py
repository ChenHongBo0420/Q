# -*- coding: utf-8 -*-
"""Untitled1019.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_bBew5eDPv_dDP0BQVlJlBVjQ9Wpq7xA
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
if not hasattr(np, 'PINF'):
    np.PINF = np.inf
if not hasattr(np, 'NINF'):
    np.NINF = -np.inf


try:
  import jax
except ModuleNotFoundError:
#   %pip install --upgrade "jax[cpu]"
# install commplax if not found
try:
  import commplax
except ModuleNotFoundError:
#   %pip install https://github.com/ChenHongBo0420/Comm/archive/master.zip
# install data api if not found
try:
  import labptptm2
except ModuleNotFoundError:
#   %pip install https://github.com/remifan/LabPtPTm2/archive/master.zip


# install GDBP if not found
try:
  import gdbp
except ModuleNotFoundError:
#   %pip install https://github.com/ChenHongBo0420/Q/archive/main.zip

# %pip install https://github.com/remifan/LabPtPTm2/archive/master.zip
# %pip uninstall numcodecs zarr -y
# %pip install "zarr==2.10.3" "numcodecs==0.10.2"


# —— 导入库 ——
import numpy as np
from tqdm.auto import tqdm
from functools import partial
import matplotlib.pyplot as plt

from commplax import util, comm
from gdbp import gdbp_base as gb, data as gdat, aux

# —— 加载数据集 ——
ds_train = gdat.load(1, 0, 4, 1)[0]
ds_test  = gdat.load(2, 0, 4, 1)[0]

# —— 只初始化 FDBP 的函数 ——
def init_fdbp(data: gdat.Input, **kwargs):
    mode  = kwargs.get('mode', 'train')
    steps = kwargs.get('steps', 3)
    dtaps = kwargs.get('dtaps', 271)
    ntaps = kwargs.get('ntaps', 71)
    rtaps = kwargs.get('rtaps', 61)
    xi    = kwargs.get('xi', 1.1)  # FDBP 的 NLC 缩放因子

    # 构造 init_fn 和 model_init
    fdbp_init  = partial(gb.fdbp_init, data.a, steps=steps)
    model_init = partial(gb.model_init, data)

    comm_conf = {
        'mode': mode,
        'steps': steps,
        'dtaps': dtaps,
        'rtaps': rtaps
    }

    # FDBP：static D-filter + static N-filter (scaled by xi)，模块列表留空
    fdbp = model_init(
        {**comm_conf,
         'ntaps': ntaps,
         'init_fn': fdbp_init(xi=xi)},
        [],                # 不需要额外指定子模块
        name='FDBP'
    )
    return fdbp

# —— 初始化训练/测试模型 ——
model_train = init_fdbp(ds_train)
model_test  = init_fdbp(ds_test, mode='test')

# —— 训练 ——
params_queue = [None] * 3
for _, p, _ in gb.train(model_train, ds_train, n_iter=3000):
    params_queue.append(p)
    params = params_queue.pop(0)

# —— 测试 ——
result, z = gb.test(model_test, params, ds_test)

# —— 输出指标 ——
print(f"全局 Q-factor: {result.QSq.total:.4f}")
print(f"全局 BER     : {result.BER.total:.4e}")

# --------------------------------------------------------------
# 1. 取出补偿前波形、理想符号、补偿后符号
# --------------------------------------------------------------
rx_before = ds_test.y[:, 0]                 # 补偿前波形（X-pol）
tx_sym    = ds_test.x[z.t.start:z.t.stop, 0]# 对齐后的 Tx 符号
rx_after  = z.val[:, 0]                     # 补偿后符号（X-pol）

# --------------------------------------------------------------
# 2. 星座图
# --------------------------------------------------------------
def block_si_snr(x, s, blk=16384):
    out=[]
    for i in range(0, len(s)-blk, blk):
        sb, xb = s[i:i+blk], x[i:i+blk]
        alpha  = np.vdot(xb, sb) / np.vdot(sb, sb)      # 最佳缩放
        e      = xb - alpha*sb
        out.append(10*np.log10(np.mean(np.abs(alpha*sb)**2) /
                               np.mean(np.abs(e)**2)))
    return np.array(out)

def plot_const(sig, title):
    plt.figure(figsize=(3.6,3.6))
    plt.scatter(sig.real[::300], sig.imag[::300], s=.3, alpha=.3)
    plt.gca().set_aspect("equal")
    plt.title(title); plt.xlabel("I"); plt.ylabel("Q")

def mse_vs_sisnr(sig, sym, seg=16000, N=400):
    rng = np.random.default_rng(0)
    idx = rng.choice(len(sym)-seg, N, replace=False)
    mse, sisnr = [], []
    for i in idx:
        s = sym[i:i+seg]; x = sig[i:i+seg]
        alpha = np.vdot(x, s) / np.vdot(s, s)
        e     = x - alpha*s
        mse  .append(np.mean(np.abs(x-s)**2))
        sisnr.append(10*np.log10(np.sum(np.abs(alpha*s)**2) /
                                 np.sum(np.abs(e)**2)))
    return np.array(mse), np.array(sisnr)
# 补偿前：2sample/sym，要 2:1 下采样
plot_const(rx_before[::2], "Before EQ  (Rx)")
plot_const(rx_after,       "After  EQ  (GDBP)")

# --------------------------------------------------------------
# 3. 块级 SI-SNR 直方图
# --------------------------------------------------------------
snr_before = block_si_snr(rx_before[::2],   tx_sym)  # 下采样后再算
snr_after  = block_si_snr(rx_after,         tx_sym)

plt.figure(figsize=(6,3))
plt.hist(snr_before, bins=80, alpha=.6, label='before EQ', density=True)
plt.hist(snr_after,  bins=80, alpha=.6, label='after  EQ', density=True)
plt.xlabel("block SI-SNR (dB)"); plt.title("SNR distribution"); plt.legend()

# --------------------------------------------------------------
# 4. MSE ↔ SI-SNR 散点（补偿后）
# --------------------------------------------------------------
mse_eq , sisnr_eq = mse_vs_sisnr(rx_after, tx_sym)
plt.figure(figsize=(4,3))
plt.scatter(mse_eq, sisnr_eq, s=8, alpha=.5)
plt.xlabel("MSE"); plt.ylabel("SI-SNR (dB)")
plt.title("After EQ  (MSE ↔ SI-SNR)")

# --------------------------------------------------------------
# 5. 打印统计
# --------------------------------------------------------------
print(f"\nAfter-EQ block SNR  mean={snr_after.mean():.2f} dB,  std={snr_after.std():.2f}")

# 1) 幅度 vs. 相位分布（After EQ）
amp  = np.abs(rx_after)
ph   = np.angle(rx_after)
fig,(ax1,ax2)=plt.subplots(1,2,figsize=(8,3))
ax1.hist(amp, bins=300, density=True);  ax1.set_title("Amplitude PDF  (After EQ)")
ax2.hist(ph , bins=300, density=True);  ax2.set_title("Phase PDF (rad)")
plt.show()

# 2) 簇重心 + 95% 置信椭圆
from matplotlib.patches import Ellipse
def plot_cluster_ellipse(sig):
    plt.figure(figsize=(3.6,3.6))
    for cen in np.unique(tx_sym):                 # ideal 16-QAM 冲击点
        idx = tx_sym == cen
        pts = rx_after[idx]
        if len(pts)==0: continue
        μ  = [pts.real.mean(), pts.imag.mean()]
        Σ  = np.cov(pts.real, pts.imag)
        w, v = np.linalg.eigh(Σ)
        angle = np.degrees(np.arctan2(*v[:,1][::-1]))
        for k in [2]:                             # 2σ ≈ 95%
            ell = Ellipse(xy=μ, width=2*k*np.sqrt(w[0]), height=2*k*np.sqrt(w[1]),
                           angle=angle, ec='r', fc='none', lw=.8)
            plt.gca().add_patch(ell)
        plt.scatter(pts.real, pts.imag, s=.2, alpha=.3)
    plt.gca().set_aspect("equal")
    plt.title("Cluster 95% ellipses")
    plt.xlabel("I"); plt.ylabel("Q")
plot_cluster_ellipse(rx_after)

from scipy.signal import welch

# unwrap phase after equalization (X-pol)
phi = np.unwrap(np.angle(rx_after))
fs  = 1.0          # symbol-rate normalized Hz
f, Sphi = welch(phi, fs=fs, nperseg=2048, scaling='density')

plt.figure(figsize=(5,3))
plt.semilogx(f, 10*np.log10(Sphi))
plt.xlabel("Offset freq (♠/Sym)"); plt.ylabel("PSD (dBrad²/Hz)")
plt.title("Phase-noise spectrum after EQ")
plt.grid(True, which='both', ls='--', lw=.4)

def block_ber(x_hat, s, blk=4096):
    e = x_hat != s
    out = [e[i:i+blk].mean() for i in range(0, len(e)-blk, blk)]
    return np.array(out)

ber_blk = block_ber(rx_after, tx_sym)
ber_sorted = np.sort(ber_blk)
p = np.linspace(0,1,len(ber_sorted),endpoint=False)

plt.figure(figsize=(4,3))
plt.semilogy(ber_sorted, 1-p)
plt.xlabel("BER (per 4 k sym block)")
plt.ylabel("1-CDF"); plt.grid()
plt.title("Block-BER tail")
plt.axhline(1e-2, ls='--', lw=.8, c='r')   # e.g., SD-FEC 2 % overhead

# 3.1 bit-mapping: 16-QAM Gray
def qam16_gray_bits(x):
    b = np.zeros((len(x),4), dtype=np.uint8)
    b[:,0] = (x.real > 0).astype(np.uint8)
    b[:,1] = (np.abs(x.real) < 1).astype(np.uint8)
    b[:,2] = (x.imag > 0).astype(np.uint8)
    b[:,3] = (np.abs(x.imag) < 1).astype(np.uint8)
    return b.reshape(-1)

bits_tx  = qam16_gray_bits(tx_sym)
bits_hat = qam16_gray_bits(rx_after)

# 3.2 block-BER with correct bit metric
blk=4096*4               # 4 bits / sym
ber_blk = [ (bits_tx[i:i+blk] != bits_hat[i:i+blk]).mean()
            for i in range(0, len(bits_tx)-blk, blk) ]
ber_blk = np.array(ber_blk)

# 3.3 BER heat-map
Ncol  = 200              # how many time-slices to show
step  = len(bits_tx)//(blk*Ncol)
matrix= ber_blk.reshape(-1, step).mean(1)  # avg into Ncol columns
plt.figure(figsize=(7,3))
plt.imshow(matrix[np.newaxis,:], aspect='auto', vmin=1e-5, vmax=1e-2,
           cmap='magma', extent=[0,len(tx_sym)/1e3,0,1])
plt.colorbar(label='BER'); plt.xlabel("kSym"); plt.yticks([])
plt.title("BER vs time (dim0)")